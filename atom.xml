<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>学习笔记</title>
  
  <subtitle>xcw</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-28T02:37:10.188Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Json Xu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>WebGl总结</title>
    <link href="http://yoursite.com/2020/04/28/opengl/opengl_01/"/>
    <id>http://yoursite.com/2020/04/28/opengl/opengl_01/</id>
    <published>2020-04-28T02:28:10.000Z</published>
    <updated>2020-04-28T02:37:10.188Z</updated>
    
    <content type="html"><![CDATA[<p>#WebGl思维导图<br><img src="GlSL.png" alt="Webgl总结"></p>]]></content>
    
    <summary type="html">
    
      WebGl基本配置
    
    </summary>
    
    
      <category term="WebGl" scheme="http://yoursite.com/categories/WebGl/"/>
    
    
      <category term="WebGl" scheme="http://yoursite.com/tags/WebGl/"/>
    
  </entry>
  
  <entry>
    <title>test</title>
    <link href="http://yoursite.com/2020/04/28/arithmetic/test/"/>
    <id>http://yoursite.com/2020/04/28/arithmetic/test/</id>
    <published>2020-04-28T02:27:03.000Z</published>
    <updated>2020-04-28T02:27:03.398Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>洗牌算法</title>
    <link href="http://yoursite.com/2020/04/28/arithmetic/shuffle/"/>
    <id>http://yoursite.com/2020/04/28/arithmetic/shuffle/</id>
    <published>2020-04-28T02:13:59.274Z</published>
    <updated>2020-04-28T02:13:59.274Z</updated>
    
    <content type="html"><![CDATA[<p>简单来说 Fisher–Yates shuffle 算法是一个用来将一个有限集合生成一个随机排列的算法（数组随机排序）。这个算法生成的随机排列是等概率的。同时这个算法非常高效。</p><h2 id="Fisher-and-Yates-的原始版"><a href="#Fisher-and-Yates-的原始版" class="headerlink" title="Fisher and Yates 的原始版"></a>Fisher and Yates 的原始版</h2><ol><li>写下从 1 到 N 的数字</li><li>取一个从 1 到剩下的数字（包括这个数字）的随机数 k</li><li>从低位开始，得到第 k 个数字（这个数字还没有被取出），把它写在独立的一个列表的最后一位</li><li>重复第 2 步，直到所有的数字都被取出</li><li>第 3 步写出的这个序列，现在就是原始数字的随机排列</li></ol><p>已经证明如果第 2 步取出的数字是真随机的，那么最后得到的排序一定也是。</p><h2 id="现代方法"><a href="#现代方法" class="headerlink" title="现代方法"></a>现代方法</h2><p>Fisher–Yates shuffle 算法的现代版本是为计算机设计的。由 Richard Durstenfeld 在1964年 描述。并且是被 Donald E. Knuth 在 《The Art of Computer Programming》 中推广。但是不管是 Durstenfeld 还是 Knuth，都没有在书的第一版中承认这个算法是 Fisher 和 Yates 的研究成果。也许他们并不知道。不过后来出版的 《The Art of Computer Programming》提到了 Fisher 和 Yates 贡献。</p><p>现代版本的描述与原始略有不同，因为如果按照原始方法，愚蠢的计算机会花很多无用的时间去计算上述第 3 步的剩余数字。<strong>这里的方法是在每次迭代时交换这个被取出的数字到原始列表的最后</strong>。这样就将时间复杂度从 O(n^2) 减小到了 <strong>O(n)</strong>。算法的伪代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-- To shuffle an array a of n elements (indices 0..n-1):</span><br><span class="line">for i from n−1 downto 1 do</span><br><span class="line">     j ← random integer such that 0 ≤ j ≤ i</span><br><span class="line">     exchange a[j] and a[i]</span><br></pre></td></tr></table></figure><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="迭代步骤演示"><a href="#迭代步骤演示" class="headerlink" title="迭代步骤演示"></a>迭代步骤演示</h3><p>根据每次迭代次数可以用下面的表格，描述这个算法的执行过程</p><table><thead><tr><th align="left">随机数取值范围</th><th align="left">随机数</th><th align="right">原始数据</th><th align="left">结果</th></tr></thead><tbody><tr><td align="left"></td><td align="left"></td><td align="right">1 2 3 4 5 6 7 8</td><td align="left"></td></tr><tr><td align="left">1-8</td><td align="left">6</td><td align="right">1 2 3 4 5 7 8</td><td align="left">6</td></tr><tr><td align="left">1-7</td><td align="left">2</td><td align="right">1 7 3 4 5 8</td><td align="left">2 6</td></tr><tr><td align="left">1–6</td><td align="left">6</td><td align="right">1 7 3 4 5</td><td align="left">8 2 6</td></tr><tr><td align="left">1–5</td><td align="left">1</td><td align="right">5 7 3 4</td><td align="left">1 8 2 6</td></tr><tr><td align="left">1–4</td><td align="left">3</td><td align="right">5 7 4</td><td align="left">3 1 8 2 6</td></tr><tr><td align="left">1–3</td><td align="left">3</td><td align="right">5 7</td><td align="left">4 3 1 8 2 6</td></tr><tr><td align="left">1–2</td><td align="left">1</td><td align="right">7</td><td align="left">5 4 3 1 8 2 6</td></tr></tbody></table><h3 id="动画演示"><a href="#动画演示" class="headerlink" title="动画演示"></a>动画演示</h3><p>下面这个动画就是整个数组 0-19 的随机排序过程</p><iframe height='317' scrolling='no' src='//codepen.io/haoyang/embed/jrvrQq/?height=317&theme-id=dark&default-tab=result&embed-version=2' frameborder='no' allowtransparency='true' allowfullscreen='true' style='width: 100%;'>See the Pen <a href='https://codepen.io/haoyang/pen/jrvrQq/' target="_blank" rel="noopener">Fisher–Yates shuffle</a> by Chuan shi (<a href='http://codepen.io/haoyang' target="_blank" rel="noopener">@haoyang</a>) on <a href='http://codepen.io' target="_blank" rel="noopener">CodePen</a>.</iframe><h2 id="JavaScript-代码实现"><a href="#JavaScript-代码实现" class="headerlink" title="JavaScript 代码实现"></a>JavaScript 代码实现</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Fisher–Yates shuffle</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.shuffle = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> input = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = input.length<span class="number">-1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> randomIndex = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(i+<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">var</span> itemAtIndex = input[randomIndex];</span><br><span class="line"></span><br><span class="line">        input[randomIndex] = input[i];</span><br><span class="line">        input[i] = itemAtIndex;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用方式也很简单，直接用数组调用这个方法即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>].shuffle()</span><br><span class="line"></span><br><span class="line"><span class="comment">//[4, 6, 3, 2, 5, 1, 7, 8] // 每次结果都是随机的</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总之，Fisher–Yates shuffle 算法是一个非常高效又公平的随机排序算法，如果有随机排序数组的需求，用这个就对了！</p>]]></content>
    
    <summary type="html">
    
      洗牌算法介绍
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Hexo介绍</title>
    <link href="http://yoursite.com/2020/04/28/note/Hexo%E9%85%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2020/04/28/note/Hexo%E9%85%8D%E7%BD%AE/</id>
    <published>2020-04-28T02:08:02.619Z</published>
    <updated>2020-04-28T02:08:02.619Z</updated>
    
    <content type="html"><![CDATA[<h3 id="布局（Layout）"><a href="#布局（Layout）" class="headerlink" title="布局（Layout）"></a>布局（Layout）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postsource&#x2F;_posts</span><br><span class="line">pagesource</span><br><span class="line">draftsource&#x2F;_drafts</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">new_post_name新文章的文件名称:title.md</span><br><span class="line">default_layout预设布局post</span><br><span class="line">auto_spacing在中文和英文之间加入空格false</span><br><span class="line">titlecase把标题转换为 title casefalse</span><br><span class="line">external_link在新标签中打开链接true</span><br><span class="line">external_link.enable在新标签中打开链接true</span><br><span class="line">external_link.field对整个网站（site）生效或仅对文章（post）生效site</span><br><span class="line">external_link.exclude需要排除的域名。主域名和子域名如 www 需分别配置[]</span><br><span class="line">filename_case把文件名称转换为 (1) 小写或 (2) 大写0</span><br><span class="line">render_drafts显示草稿false</span><br><span class="line">post_asset_folder启动 Asset 文件夹false</span><br><span class="line">relative_link把链接改为与根目录的相对位址false</span><br><span class="line">future显示未来的文章true</span><br><span class="line">highlight代码块的设置</span><br><span class="line">highlight.enable开启代码块高亮true</span><br><span class="line">highlight.auto_detect如果未指定语言，则启用自动检测false</span><br><span class="line">highlight.line_number显示行数</span><br><span class="line">Enabling this option will also enable wrap optiontrue</span><br><span class="line">highlight.tab_replace用 n 个空格替换 tabs；如果值为空，则不会替换 tabs&#39;&#39;</span><br><span class="line">highlight.wrapWrap the code block in &lt;table&gt;true</span><br><span class="line">highlight.hljsUse the hljs-* prefix for CSS classesfalse</span><br></pre></td></tr></table></figure><h3 id="Front-matter"><a href="#Front-matter" class="headerlink" title="Front-matter"></a>Front-matter</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Front-matter 是文件最上方以 --- 分隔的区域，用于指定个别文件的变量，举例来说：</span><br><span class="line">layout布局</span><br><span class="line">title标题文章的文件名</span><br><span class="line">date建立日期文件建立日期</span><br><span class="line">updated更新日期文件更新日期</span><br><span class="line">comments开启文章的评论功能true</span><br><span class="line">tags标签（不适用于分页）</span><br><span class="line">categories分类（不适用于分页）</span><br><span class="line">permalink覆盖文章网址</span><br><span class="line">keywords仅用于 meta 标签和 Open Graph 的关键词（不推荐使用）</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      Hexo基本配置
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 命令</title>
    <link href="http://yoursite.com/2020/04/27/note/Hexo_%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2020/04/27/note/Hexo_%E5%91%BD%E4%BB%A4/</id>
    <published>2020-04-27T12:43:32.240Z</published>
    <updated>2020-04-27T12:43:32.241Z</updated>
    
    <content type="html"><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo</span><br><span class="line">$ hexo init &lt;folder&gt;</span><br><span class="line">$ <span class="built_in">cd</span> &lt;folder&gt;</span><br><span class="line">$ npm install</span><br></pre></td></tr></table></figure><h3 id="创建新的博客"><a href="#创建新的博客" class="headerlink" title="创建新的博客"></a>创建新的博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><h3 id="开启博客"><a href="#开启博客" class="headerlink" title="开启博客"></a>开启博客</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>###部署</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><h3 id="新建页面"><a href="#新建页面" class="headerlink" title="新建页面"></a>新建页面</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><h3 id="知道路径"><a href="#知道路径" class="headerlink" title="知道路径"></a>知道路径</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page --path about/me <span class="string">"About me"</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      hexo 常用命令
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>game</title>
    <link href="http://yoursite.com/2020/04/27/game/H5/"/>
    <id>http://yoursite.com/2020/04/27/game/H5/</id>
    <published>2020-04-27T12:42:50.000Z</published>
    <updated>2020-04-27T13:01:17.019Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="game" scheme="http://yoursite.com/categories/game/"/>
    
    
      <category term="game" scheme="http://yoursite.com/tags/game/"/>
    
  </entry>
  
  <entry>
    <title>This总结</title>
    <link href="http://yoursite.com/2020/04/27/web/Js-this/"/>
    <id>http://yoursite.com/2020/04/27/web/Js-this/</id>
    <published>2020-04-27T12:12:36.460Z</published>
    <updated>2020-04-27T12:12:36.460Z</updated>
    
    <content type="html"><![CDATA[<ul><li>content<br>{:toc}</li></ul><p>本文为慕课网 <a href="http://www.imooc.com/learn/277" target="_blank" rel="noopener">JavaScript深入浅出</a> JavaScript 中的 this笔记。</p><h2 id="全局的-this"><a href="#全局的-this" class="headerlink" title="全局的 this"></a>全局的 this</h2><p>全局 this 一般指向全局对象，浏览器中的全局对象就是 <code>window</code>。</p><p>例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span>.document === <span class="built_in">document</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>.a = <span class="number">91</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.a); <span class="comment">//91</span></span><br></pre></td></tr></table></figure><h2 id="一般函数的-this"><a href="#一般函数的-this" class="headerlink" title="一般函数的 this"></a>一般函数的 this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f1() === <span class="built_in">window</span>);<span class="comment">//true, global object</span></span><br></pre></td></tr></table></figure><p>可以看到一般函数的 this 也指向 window，在 nodeJS 中为 global object</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    "use strict"</span>;<span class="comment">//使用严格模式</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(f1() === <span class="literal">undefined</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure><p>严格模式中，函数的 this 为 undefined</p><h2 id="作为对象方法的函数的-this"><a href="#作为对象方法的函数的-this" class="headerlink" title="作为对象方法的函数的 this"></a>作为对象方法的函数的 this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    prop: <span class="number">37</span>,</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// 37</span></span><br></pre></td></tr></table></figure><p>上述代码通过字面量创建对象 o。</p><p>f 为对象 o 的方法。这个方法的 this 指向这个对象，在这里即对象 o。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    prop: <span class="number">37</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">independent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.prop;</span><br><span class="line">&#125;</span><br><span class="line">o.f = independent;</span><br><span class="line"><span class="built_in">console</span>.log(o.f()); <span class="comment">// 37</span></span><br></pre></td></tr></table></figure><p>上面的代码，创建了对象 o，但是没有给对象 o，添加方法。而是通过 <code>o.f = independent</code> 临时添加了方法属性。这样这个方法中的 this 同样也指向这个对象 o。</p><h2 id="对象原型链上的-this"><a href="#对象原型链上的-this" class="headerlink" title="对象原型链上的 this"></a>对象原型链上的 this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    f: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">Object</span>.create(o);</span><br><span class="line">p.a = <span class="number">1</span>;</span><br><span class="line">p.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p.f()); <span class="comment">//3</span></span><br></pre></td></tr></table></figure><p>通过 <code>var p = Object.create(o)</code> 创建的对象，p 是基于原型 o 创建出的对象。</p><p>p 的原型是 o，调用 f() 的时候是调用了 o 上的方法 f()，这里面的 this 是可以指向当前对象的，即对象 p。</p><h2 id="get-set-方法与-this"><a href="#get-set-方法与-this" class="headerlink" title="get/set 方法与 this"></a>get/set 方法与 this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">modulus</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.sqrt(<span class="keyword">this</span>.re * <span class="keyword">this</span>.re + <span class="keyword">this</span>.im * <span class="keyword">this</span>.im);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    re: <span class="number">1</span>,</span><br><span class="line">    im: <span class="number">-1</span>,</span><br><span class="line">    <span class="keyword">get</span> phase() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.atan2(<span class="keyword">this</span>.im, <span class="keyword">this</span>.re);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">'modulus'</span>, &#123;</span><br><span class="line">    <span class="keyword">get</span>: modulus,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">&#125;);</span><br><span class="line">console.log(o.phase, o.modulus); // -0.78 1.4142</span><br></pre></td></tr></table></figure><p>get/set 方法中的 this 也会指向 get/set 方法所在的对象的。</p><h2 id="构造器中的-this"><a href="#构造器中的-this" class="headerlink" title="构造器中的 this"></a>构造器中的 this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyClass</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">25</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> MyClass();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//25</span></span><br></pre></td></tr></table></figure><p>new MyClass() 的时候，MyClass()中的 this 会指向一个空对象，这个对象的原型会指向 MyClass.prototype。MyClass()没有返回值或者返回为基本类型时，默认将 this 返回。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">C2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.a = <span class="number">26</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        a: <span class="number">24</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o = <span class="keyword">new</span> C2();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//24</span></span><br></pre></td></tr></table></figure><p>因为返回了对象，将这个对象作为返回值</p><h2 id="call-apply-方法与-this"><a href="#call-apply-方法与-this" class="headerlink" title="call/apply 方法与 this"></a>call/apply 方法与 this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">c, d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a + <span class="keyword">this</span>.b + c + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line">add.call(o, <span class="number">5</span>, <span class="number">7</span>); <span class="comment">// 1 + 3 + 5 + 7 = 16</span></span><br><span class="line">add.apply(o, [<span class="number">10</span>, <span class="number">20</span>]); <span class="comment">// 1 + 3 + 10 + 20 = 34</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">Object</span>.prototype.toString.call(<span class="keyword">this</span>));</span><br><span class="line">&#125;</span><br><span class="line">bar.call(<span class="number">7</span>); <span class="comment">// "[object Number]"</span></span><br></pre></td></tr></table></figure><h2 id="bind-方法与-this"><a href="#bind-方法与-this" class="headerlink" title="bind 方法与 this"></a>bind 方法与 this</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = f.bind(&#123;</span><br><span class="line">    a: <span class="string">"test"</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(g()); <span class="comment">// test</span></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    a: <span class="number">37</span>,</span><br><span class="line">    f: f,</span><br><span class="line">    g: g</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.f(), o.g()); <span class="comment">// 37, test</span></span><br></pre></td></tr></table></figure><p>绑定之后再调用时，仍然会按绑定时的内容走，所以 o.g() 结果是 test</p>]]></content>
    
    <summary type="html">
    
      JavaScript this的总结。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS作用域</title>
    <link href="http://yoursite.com/2020/04/27/web/Js_%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/04/27/web/Js_%E4%BD%9C%E7%94%A8%E5%9F%9F/</id>
    <published>2020-04-27T12:03:03.512Z</published>
    <updated>2020-04-27T12:03:03.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="JavaScript-作用域"><a href="#JavaScript-作用域" class="headerlink" title="JavaScript 作用域"></a>JavaScript 作用域</h2><p>作用域就是变量与函数的可访问范围。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。</p><hr><h3 id="全局作用域-Global-Scope"><a href="#全局作用域-Global-Scope" class="headerlink" title="全局作用域(Global Scope)"></a>全局作用域(Global Scope)</h3><p>在代码中任何地方都能访问到的对象拥有全局作用域，一般来说以下 3 种情形拥有全局作用域。</p><ol><li>最外层函数和在最外层函数外面定义的变量拥有全局作用域</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outVariable = <span class="string">"我是最外层变量"</span>; <span class="comment">//最外层变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outFun</span>(<span class="params"></span>) </span>&#123; <span class="comment">//最外层函数</span></span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">"内层变量"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>) </span>&#123; <span class="comment">//内层函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(inVariable);</span><br><span class="line">    &#125;</span><br><span class="line">    innerFun();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(outVariable); <span class="comment">//我是最外层变量</span></span><br><span class="line">outFun(); <span class="comment">//内层变量</span></span><br><span class="line"><span class="built_in">console</span>.log(inVariable); <span class="comment">//inVariable is not defined</span></span><br><span class="line">innerFun(); <span class="comment">//innerFun is not defined</span></span><br></pre></td></tr></table></figure><ol start="2"><li>所有末定义直接赋值的变量自动声明为拥有全局作用域</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outFun2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    variable = <span class="string">"未定义直接赋值的变量"</span>;</span><br><span class="line">    <span class="keyword">var</span> inVariable2 = <span class="string">"内层变量2"</span>;</span><br><span class="line">&#125;</span><br><span class="line">outFun2();<span class="comment">//要先执行这个函数，否则根本不知道里面是啥</span></span><br><span class="line"><span class="built_in">console</span>.log(variable); <span class="comment">//未定义直接赋值的变量</span></span><br><span class="line"><span class="built_in">console</span>.log(inVariable2); <span class="comment">//inVariable2 is not defined</span></span><br></pre></td></tr></table></figure><ol start="3"><li>所有window对象的属性拥有全局作用域<br> window对象的内置属性都拥有全局作用域，例如 <code>window.name</code>、<code>window.location</code>、<code>window.top</code> 等。</li></ol><h3 id="局部作用域-Local-Scope"><a href="#局部作用域-Local-Scope" class="headerlink" title="局部作用域(Local Scope)"></a>局部作用域(Local Scope)</h3><p>和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的例如函数内部，所有在一些地方也会看到有人把这种作用域称为函数作用域<br>。</p><p>如 1. 中的变量 <code>inVariable</code> 和函数 <code>innerFun</code> 都只拥有局部作用域。</p><hr><h3 id="再补充几个例子"><a href="#再补充几个例子" class="headerlink" title="再补充几个例子"></a>再补充几个例子</h3><ul><li>全局作用域，函数作用域，eval作用域</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>; <span class="comment">// 全局</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">20</span>;<span class="comment">// 函数</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// error, b in not defined</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="string">"var a = 1;"</span>); <span class="comment">// eval</span></span><br></pre></td></tr></table></figure><ul><li>JavaScript 中没有块作用域</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> item <span class="keyword">in</span> &#123;</span><br><span class="line">    a: <span class="number">1</span>,</span><br><span class="line">    b: <span class="number">2</span></span><br><span class="line">&#125;) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(item); <span class="comment">// item still in scope</span></span><br></pre></td></tr></table></figure><hr><h2 id="作用域链-Scope-Chain"><a href="#作用域链-Scope-Chain" class="headerlink" title="作用域链(Scope Chain)"></a>作用域链(Scope Chain)</h2><p>在 JavaScript 中，函数也是对象，实际上，JavaScript 里一切都是对象。函数对象和其它对象一样，拥有可以通过代码访问的属性和一系列仅供 JavaScript 引擎访问的内部属性。其中一个内部属性是 [[Scope]]，由 ECMA-262 标准第三版定义，该内部属性包含了函数被创建的作用域中对象的集合，这个集合被称为函数的作用域链，它决定了哪些数据能被函数访问。</p><ol><li>在函数创建时，它的作用域链中会填入一个全局对象，该全局对象包含了所有全局变量。</li><li>函数执行时会创建一个称为“运行期上下文(execution context)”的内部对象，运行期上下文定义了函数执行时的环境。每个运行期上下文都有自己的作用域链，用于标识符解析，当运行期上下文被创建时，而它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。</li><li>这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。它们共同组成了一个新的对象，叫“活动对象(activation object)”，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，然后此对象会被推入作用域链的前端。</li><li>当运行期上下文被销毁，活动对象也随之销毁。</li></ol><p>在函数执行过程中，每遇到一个变量，都会经历一次标识符解析过程以决定从哪里获取和存储数据。该过程从作用域链头部，也就是从活动对象开始搜索，查找同名的标识符，如果找到了就使用这个标识符对应的变量，如果没找到继续搜索作用域链中的下一个对象，如果搜索完所有对象都未找到，则认为该标识符未定义。函数执行过程中，每个标识符都要经历这样的搜索过程。</p><hr><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>举一个作用域链的例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> outVariable = <span class="string">"我是最外层变量"</span>; <span class="comment">//最外层变量</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outFun</span>(<span class="params"></span>) </span>&#123; <span class="comment">//最外层函数</span></span><br><span class="line">    <span class="keyword">var</span> inVariable = <span class="string">"内层变量"</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerFun</span>(<span class="params"></span>) </span>&#123; <span class="comment">//内层函数</span></span><br><span class="line">        <span class="built_in">console</span>.log(inVariable);</span><br><span class="line">        <span class="keyword">var</span> tempVariable = inVariable;</span><br><span class="line">    &#125;</span><br><span class="line">    innerFun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对最开始的代码稍加修改</p><p>其作用域链为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window</span><br><span class="line">├──outVariable</span><br><span class="line">└──outFun()</span><br><span class="line">   ├──inVariable</span><br><span class="line">   └──innerFun()</span><br><span class="line">      └──tempVariable</span><br></pre></td></tr></table></figure><p>对于 <code>innerFun()</code>，其作用域链包含 3 个对象：innerFun() 自己的变量对象、outFun()的变量对象、全局变量对象。</p><hr><h4 id="特例-构造器创建的函数"><a href="#特例-构造器创建的函数" class="headerlink" title="特例-构造器创建的函数"></a>特例-构造器创建的函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> func = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"console.log(typeof i);"</span>);</span><br><span class="line">    func(); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">outer();</span><br></pre></td></tr></table></figure><p>通过构造器创建的函数是访问不到外层的局部变量的。</p><hr><h3 id="延长作用域链"><a href="#延长作用域链" class="headerlink" title="延长作用域链"></a>延长作用域链</h3><p>有些语句可以在作用域链的前端临时增加一个变量对象，该变量对象会在代码执行后被移除。有两种情况下会发生这种现象。</p><ul><li><code>try-catch</code> 语句中的 <code>catch</code> 块</li><li><code>with</code> 语句</li></ul><p>对 with 来说，将会指定对象添加到作用域链中。对 catch 来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明。</p><hr><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>从作用域链的结构可以看出，在运行期上下文的作用域链中，标识符所在的位置越深，读写速度就会越慢。因为全局变量总是存在于运行期上下文作用域链的最末端，因此在标识符解析的时候，查找全局变量是最慢的。所以，在编写代码的时候应尽量少使用全局变量，尽可能使用局部变量。一个好的经验法则是：如果一个跨作用域的对象被引用了一次以上，则先把它存储到局部变量里再使用。</p><hr><h2 id="VO-amp-AO"><a href="#VO-amp-AO" class="headerlink" title="VO &amp; AO"></a>VO &amp; AO</h2><h3 id="变量初始化阶段"><a href="#变量初始化阶段" class="headerlink" title="变量初始化阶段"></a>变量初始化阶段</h3><ul><li><p>JS解释器如何找到我们定义的函数和变量？</p><p>  变量对象 (Variable Object, 缩写为VO) 是一个抽象概念中的“对象”，它用于存储执行上下文中的：</p><ol><li>变量</li><li>函数声明</li><li>函数参数</li></ol></li><li><p>VO按照如下顺序填充:</p><ol><li>函数参数 (若未传入，初始化该参数值为undefined)    </li><li>函数声明 (若发生命名冲突，会覆盖)   </li><li>变量声明 (初始化变量值为 undefined，若发生命名冲突，会忽略。)</li></ol></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">100</span>); <span class="comment">// funtion x()</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo2</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">50</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo2(<span class="number">110</span>); <span class="comment">// 50</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo3(); <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> x;</span><br><span class="line">    <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">foo4(); <span class="comment">// funtion x()</span></span><br></pre></td></tr></table></figure><p><strong>注：函数表达式不会影响 VO</strong></p><hr><h3 id="代码执行阶段"><a href="#代码执行阶段" class="headerlink" title="代码执行阶段"></a>代码执行阶段</h3><p>给 VO 对象内的变量赋值。</p><p>VO 变为 AO （活动对象 activation object）。</p><hr><h3 id="例"><a href="#例" class="headerlink" title="例"></a>例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">alert(x); <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line">alert(x); <span class="comment">// 10</span></span><br><span class="line">x = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">alert(x); <span class="comment">// 20</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(a); <span class="comment">// 1</span></span><br><span class="line">alert(b); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><hr><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.laruence.com/2009/05/28/863.html" target="_blank" rel="noopener">鸟哥：Javascript作用域原理</a></li><li><a href="http://www.cnblogs.com/lhb25/archive/2011/09/06/javascript-scope-chain.html" target="_blank" rel="noopener">理解 JavaScript 作用域和作用域链</a></li><li><a href="http://www.imooc.com/learn/277" target="_blank" rel="noopener">JavaScript 深入浅出-慕课网</a></li></ul>]]></content>
    
    <summary type="html">
    
      JavaScript 作用域和作用域链学习笔记。
    
    </summary>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Hexo 插件</title>
    <link href="http://yoursite.com/2020/04/27/note/Hexo_%E6%8F%92%E4%BB%B6/"/>
    <id>http://yoursite.com/2020/04/27/note/Hexo_%E6%8F%92%E4%BB%B6/</id>
    <published>2020-04-27T12:01:08.852Z</published>
    <updated>2020-04-27T12:01:08.852Z</updated>
    
    <content type="html"><![CDATA[<p>#hexo-autonofollow<br>Github：<a href="https://github.com/liuzc/hexo-autonofollow" target="_blank" rel="noopener">https://github.com/liuzc/hexo-autonofollow</a></p><p>简介：自动为站外链接添加nofollow属性</p><p>安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-autonofollow --save</span><br></pre></td></tr></table></figure><p>配置：</p><p>在博客配置文件_config.yml中添加</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">nofollow:</span><br><span class="line">  enable: <span class="literal">true</span></span><br><span class="line">  exclude:</span><br><span class="line">    - exclude1.com</span><br><span class="line">    - exclude2.com</span><br></pre></td></tr></table></figure><blockquote><ul><li>enable - 是否启用</li><li>exclude - 排除域名</li></ul></blockquote><p>#hexo-baidu-url-submit<br>Github：<a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">https://github.com/huiwang/hexo-baidu-url-submit</a></p><p>简介：主动推送Hexo博客新链接至百度搜索引擎，解决百度爬虫被禁止访问的问题，提升网站收录质量和速度。</p><p>安装：</p><p>$ npm install hexo-baidu-url-submit –save<br>配置：</p><p>在博客配置文件_config.yml中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">baidu_url_submit:</span><br><span class="line">  count: 1 ## 提交最新的一个链接</span><br><span class="line">  host: blog.cofess.com ## 在百度站长平台中注册的域名</span><br><span class="line">  token: your_token ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!</span><br><span class="line">  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</span><br></pre></td></tr></table></figure><blockquote><ul><li>token - 您得注册百度站长工具，然后在工具-&gt;网页抓取-&gt;链接提交里找到你的密匙。<br>其次，_config.ym文件中url的值， 必须是百度站长平台注册的域名， 比如:</li></ul></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">url: blog.cofess.com</span><br><span class="line">root: &#x2F;</span><br><span class="line">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br></pre></td></tr></table></figure><p>最后，加入新的deployer:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">- type: baidu_url_submitter</span><br></pre></td></tr></table></figure><p>执行hexo deploy的时候，新的链接就会被推送百度了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#hexo-autonofollow&lt;br&gt;Github：&lt;a href=&quot;https://github.com/liuzc/hexo-autonofollow&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/liuzc
      
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yoursite.com/categories/Hexo/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
  </entry>
  
</feed>
